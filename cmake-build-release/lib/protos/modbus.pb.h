// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modbus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modbus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modbus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modbus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modbus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modbus_2eproto;
class ModbusConfig;
struct ModbusConfigDefaultTypeInternal;
extern ModbusConfigDefaultTypeInternal _ModbusConfig_default_instance_;
class ModbusConfigResponse;
struct ModbusConfigResponseDefaultTypeInternal;
extern ModbusConfigResponseDefaultTypeInternal _ModbusConfigResponse_default_instance_;
class ModbusConfig_ModbusDevice;
struct ModbusConfig_ModbusDeviceDefaultTypeInternal;
extern ModbusConfig_ModbusDeviceDefaultTypeInternal _ModbusConfig_ModbusDevice_default_instance_;
class ModbusConfig_ModbusDevice_ModbusRTUSlaves;
struct ModbusConfig_ModbusDevice_ModbusRTUSlavesDefaultTypeInternal;
extern ModbusConfig_ModbusDevice_ModbusRTUSlavesDefaultTypeInternal _ModbusConfig_ModbusDevice_ModbusRTUSlaves_default_instance_;
class ModbusConfig_ModbusDevice_ModbusTCPSlaves;
struct ModbusConfig_ModbusDevice_ModbusTCPSlavesDefaultTypeInternal;
extern ModbusConfig_ModbusDevice_ModbusTCPSlavesDefaultTypeInternal _ModbusConfig_ModbusDevice_ModbusTCPSlaves_default_instance_;
class ModbusConfig_ModbusDevice_ModbusTag;
struct ModbusConfig_ModbusDevice_ModbusTagDefaultTypeInternal;
extern ModbusConfig_ModbusDevice_ModbusTagDefaultTypeInternal _ModbusConfig_ModbusDevice_ModbusTag_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ModbusConfig* Arena::CreateMaybeMessage<::ModbusConfig>(Arena*);
template<> ::ModbusConfigResponse* Arena::CreateMaybeMessage<::ModbusConfigResponse>(Arena*);
template<> ::ModbusConfig_ModbusDevice* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice>(Arena*);
template<> ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusRTUSlaves>(Arena*);
template<> ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusTCPSlaves>(Arena*);
template<> ::ModbusConfig_ModbusDevice_ModbusTag* Arena::CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusTag>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Parity : int {
  ODD = 0,
  EVEN = 1,
  NONE = 2,
  Parity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Parity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Parity_IsValid(int value);
constexpr Parity Parity_MIN = ODD;
constexpr Parity Parity_MAX = NONE;
constexpr int Parity_ARRAYSIZE = Parity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Parity_descriptor();
template<typename T>
inline const std::string& Parity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Parity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Parity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Parity_descriptor(), enum_t_value);
}
inline bool Parity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Parity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Parity>(
    Parity_descriptor(), name, value);
}
enum BaudRate : int {
  BAUD110 = 0,
  BAUD300 = 1,
  BAUD600 = 2,
  BAUD1200 = 3,
  BAUD2400 = 4,
  BAUD4800 = 5,
  BAUD9600 = 6,
  BAUD14400 = 7,
  BAUD19200 = 8,
  BAUD38400 = 9,
  BAUD56000 = 10,
  BAUD57600 = 11,
  BAUD115200 = 12,
  BAUD125000 = 13,
  BAUD256000 = 14,
  BaudRate_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BaudRate_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BaudRate_IsValid(int value);
constexpr BaudRate BaudRate_MIN = BAUD110;
constexpr BaudRate BaudRate_MAX = BAUD256000;
constexpr int BaudRate_ARRAYSIZE = BaudRate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BaudRate_descriptor();
template<typename T>
inline const std::string& BaudRate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BaudRate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BaudRate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BaudRate_descriptor(), enum_t_value);
}
inline bool BaudRate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BaudRate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BaudRate>(
    BaudRate_descriptor(), name, value);
}
enum FunctionCode : int {
  RRAD_COIL = 0,
  READ_DISCRETE_INPUTS = 1,
  READ_MULTIPLE_HOLDING_REGISTERS = 2,
  READ_INPUT_REGISTERS = 3,
  WRITE_SINGLE_COIL = 4,
  WRITE_SINGLE_HOLDING_REGISTER = 5,
  WRITE_MULTIPLE_COILS = 6,
  WRITE_MULTIPLE_HLDING_REGISTERS = 7,
  FunctionCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FunctionCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FunctionCode_IsValid(int value);
constexpr FunctionCode FunctionCode_MIN = RRAD_COIL;
constexpr FunctionCode FunctionCode_MAX = WRITE_MULTIPLE_HLDING_REGISTERS;
constexpr int FunctionCode_ARRAYSIZE = FunctionCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionCode_descriptor();
template<typename T>
inline const std::string& FunctionCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionCode_descriptor(), enum_t_value);
}
inline bool FunctionCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FunctionCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionCode>(
    FunctionCode_descriptor(), name, value);
}
enum ModbusDataType : int {
  MBOOLEAN = 0,
  MINT8 = 1,
  MUINT8 = 2,
  MINT16 = 3,
  MUINT16 = 4,
  MINT32 = 5,
  MUINT32 = 6,
  MINT64 = 7,
  MUINT64 = 8,
  MFLOAT32 = 9,
  MFLOAT64 = 10,
  MSTRING = 11,
  ModbusDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModbusDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ModbusDataType_IsValid(int value);
constexpr ModbusDataType ModbusDataType_MIN = MBOOLEAN;
constexpr ModbusDataType ModbusDataType_MAX = MSTRING;
constexpr int ModbusDataType_ARRAYSIZE = ModbusDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModbusDataType_descriptor();
template<typename T>
inline const std::string& ModbusDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModbusDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModbusDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModbusDataType_descriptor(), enum_t_value);
}
inline bool ModbusDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModbusDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModbusDataType>(
    ModbusDataType_descriptor(), name, value);
}
// ===================================================================

class ModbusConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfigResponse) */ {
 public:
  inline ModbusConfigResponse() : ModbusConfigResponse(nullptr) {}
  ~ModbusConfigResponse() override;
  explicit constexpr ModbusConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModbusConfigResponse(const ModbusConfigResponse& from);
  ModbusConfigResponse(ModbusConfigResponse&& from) noexcept
    : ModbusConfigResponse() {
    *this = ::std::move(from);
  }

  inline ModbusConfigResponse& operator=(const ModbusConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfigResponse& operator=(ModbusConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ModbusConfigResponse*>(
               &_ModbusConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModbusConfigResponse& a, ModbusConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModbusConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModbusConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfigResponse";
  }
  protected:
  explicit ModbusConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDescFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // string errorDesc = 3;
  void clear_errordesc();
  const std::string& errordesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errordesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errordesc();
  PROTOBUF_NODISCARD std::string* release_errordesc();
  void set_allocated_errordesc(std::string* errordesc);
  private:
  const std::string& _internal_errordesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errordesc(const std::string& value);
  std::string* _internal_mutable_errordesc();
  public:

  // bool Success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 errorCode = 2;
  void clear_errorcode();
  int32_t errorcode() const;
  void set_errorcode(int32_t value);
  private:
  int32_t _internal_errorcode() const;
  void _internal_set_errorcode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errordesc_;
  bool success_;
  int32_t errorcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice_ModbusRTUSlaves final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice.ModbusRTUSlaves) */ {
 public:
  inline ModbusConfig_ModbusDevice_ModbusRTUSlaves() : ModbusConfig_ModbusDevice_ModbusRTUSlaves(nullptr) {}
  ~ModbusConfig_ModbusDevice_ModbusRTUSlaves() override;
  explicit constexpr ModbusConfig_ModbusDevice_ModbusRTUSlaves(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModbusConfig_ModbusDevice_ModbusRTUSlaves(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from);
  ModbusConfig_ModbusDevice_ModbusRTUSlaves(ModbusConfig_ModbusDevice_ModbusRTUSlaves&& from) noexcept
    : ModbusConfig_ModbusDevice_ModbusRTUSlaves() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice_ModbusRTUSlaves& operator=(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice_ModbusRTUSlaves& operator=(ModbusConfig_ModbusDevice_ModbusRTUSlaves&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusConfig_ModbusDevice_ModbusRTUSlaves& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusConfig_ModbusDevice_ModbusRTUSlaves* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice_ModbusRTUSlaves*>(
               &_ModbusConfig_ModbusDevice_ModbusRTUSlaves_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModbusConfig_ModbusDevice_ModbusRTUSlaves& a, ModbusConfig_ModbusDevice_ModbusRTUSlaves& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice_ModbusRTUSlaves* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusConfig_ModbusDevice_ModbusRTUSlaves* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusConfig_ModbusDevice_ModbusRTUSlaves* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusRTUSlaves>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModbusConfig_ModbusDevice_ModbusRTUSlaves& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice_ModbusRTUSlaves* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice.ModbusRTUSlaves";
  }
  protected:
  explicit ModbusConfig_ModbusDevice_ModbusRTUSlaves(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kClientIDFieldNumber = 2,
    kBaudRateFieldNumber = 3,
    kParityFieldNumber = 4,
    kStartBitFieldNumber = 5,
    kStopBitFieldNumber = 6,
    kDataBitFieldNumber = 7,
  };
  // string clientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // string clientID = 2;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // .BaudRate baudRate = 3;
  void clear_baudrate();
  ::BaudRate baudrate() const;
  void set_baudrate(::BaudRate value);
  private:
  ::BaudRate _internal_baudrate() const;
  void _internal_set_baudrate(::BaudRate value);
  public:

  // .Parity parity = 4;
  void clear_parity();
  ::Parity parity() const;
  void set_parity(::Parity value);
  private:
  ::Parity _internal_parity() const;
  void _internal_set_parity(::Parity value);
  public:

  // int32 startBit = 5;
  void clear_startbit();
  int32_t startbit() const;
  void set_startbit(int32_t value);
  private:
  int32_t _internal_startbit() const;
  void _internal_set_startbit(int32_t value);
  public:

  // int32 stopBit = 6;
  void clear_stopbit();
  int32_t stopbit() const;
  void set_stopbit(int32_t value);
  private:
  int32_t _internal_stopbit() const;
  void _internal_set_stopbit(int32_t value);
  public:

  // int32 dataBit = 7;
  void clear_databit();
  int32_t databit() const;
  void set_databit(int32_t value);
  private:
  int32_t _internal_databit() const;
  void _internal_set_databit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice.ModbusRTUSlaves)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  int baudrate_;
  int parity_;
  int32_t startbit_;
  int32_t stopbit_;
  int32_t databit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice_ModbusTCPSlaves final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice.ModbusTCPSlaves) */ {
 public:
  inline ModbusConfig_ModbusDevice_ModbusTCPSlaves() : ModbusConfig_ModbusDevice_ModbusTCPSlaves(nullptr) {}
  ~ModbusConfig_ModbusDevice_ModbusTCPSlaves() override;
  explicit constexpr ModbusConfig_ModbusDevice_ModbusTCPSlaves(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModbusConfig_ModbusDevice_ModbusTCPSlaves(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from);
  ModbusConfig_ModbusDevice_ModbusTCPSlaves(ModbusConfig_ModbusDevice_ModbusTCPSlaves&& from) noexcept
    : ModbusConfig_ModbusDevice_ModbusTCPSlaves() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice_ModbusTCPSlaves& operator=(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice_ModbusTCPSlaves& operator=(ModbusConfig_ModbusDevice_ModbusTCPSlaves&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusConfig_ModbusDevice_ModbusTCPSlaves& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusConfig_ModbusDevice_ModbusTCPSlaves* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice_ModbusTCPSlaves*>(
               &_ModbusConfig_ModbusDevice_ModbusTCPSlaves_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModbusConfig_ModbusDevice_ModbusTCPSlaves& a, ModbusConfig_ModbusDevice_ModbusTCPSlaves& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice_ModbusTCPSlaves* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusConfig_ModbusDevice_ModbusTCPSlaves* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusConfig_ModbusDevice_ModbusTCPSlaves* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusTCPSlaves>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModbusConfig_ModbusDevice_ModbusTCPSlaves& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice_ModbusTCPSlaves* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice.ModbusTCPSlaves";
  }
  protected:
  explicit ModbusConfig_ModbusDevice_ModbusTCPSlaves(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kClientIDFieldNumber = 2,
    kIPFieldNumber = 3,
    kPortFieldNumber = 4,
  };
  // string clientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // string clientID = 2;
  void clear_clientid();
  const std::string& clientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* clientid);
  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(const std::string& value);
  std::string* _internal_mutable_clientid();
  public:

  // string IP = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int32 port = 4;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice.ModbusTCPSlaves)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice_ModbusTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice.ModbusTag) */ {
 public:
  inline ModbusConfig_ModbusDevice_ModbusTag() : ModbusConfig_ModbusDevice_ModbusTag(nullptr) {}
  ~ModbusConfig_ModbusDevice_ModbusTag() override;
  explicit constexpr ModbusConfig_ModbusDevice_ModbusTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModbusConfig_ModbusDevice_ModbusTag(const ModbusConfig_ModbusDevice_ModbusTag& from);
  ModbusConfig_ModbusDevice_ModbusTag(ModbusConfig_ModbusDevice_ModbusTag&& from) noexcept
    : ModbusConfig_ModbusDevice_ModbusTag() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice_ModbusTag& operator=(const ModbusConfig_ModbusDevice_ModbusTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice_ModbusTag& operator=(ModbusConfig_ModbusDevice_ModbusTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusConfig_ModbusDevice_ModbusTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusConfig_ModbusDevice_ModbusTag* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice_ModbusTag*>(
               &_ModbusConfig_ModbusDevice_ModbusTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModbusConfig_ModbusDevice_ModbusTag& a, ModbusConfig_ModbusDevice_ModbusTag& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice_ModbusTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusConfig_ModbusDevice_ModbusTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusConfig_ModbusDevice_ModbusTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice_ModbusTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModbusConfig_ModbusDevice_ModbusTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModbusConfig_ModbusDevice_ModbusTag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice_ModbusTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice.ModbusTag";
  }
  protected:
  explicit ModbusConfig_ModbusDevice_ModbusTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 1,
    kTagIdFieldNumber = 2,
    kServerIdFieldNumber = 3,
    kDataTypeFieldNumber = 4,
    kFunctionCodeFieldNumber = 5,
    kIntervalTimeFieldNumber = 6,
    kStartingAddressFieldNumber = 7,
    kNumberOfRegistersFieldNumber = 8,
  };
  // string tagName = 1;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_NODISCARD std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // string tagId = 2;
  void clear_tagid();
  const std::string& tagid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagid();
  PROTOBUF_NODISCARD std::string* release_tagid();
  void set_allocated_tagid(std::string* tagid);
  private:
  const std::string& _internal_tagid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagid(const std::string& value);
  std::string* _internal_mutable_tagid();
  public:

  // string serverId = 3;
  void clear_serverid();
  const std::string& serverid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverid();
  PROTOBUF_NODISCARD std::string* release_serverid();
  void set_allocated_serverid(std::string* serverid);
  private:
  const std::string& _internal_serverid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverid(const std::string& value);
  std::string* _internal_mutable_serverid();
  public:

  // .ModbusDataType dataType = 4;
  void clear_datatype();
  ::ModbusDataType datatype() const;
  void set_datatype(::ModbusDataType value);
  private:
  ::ModbusDataType _internal_datatype() const;
  void _internal_set_datatype(::ModbusDataType value);
  public:

  // .FunctionCode functionCode = 5;
  void clear_functioncode();
  ::FunctionCode functioncode() const;
  void set_functioncode(::FunctionCode value);
  private:
  ::FunctionCode _internal_functioncode() const;
  void _internal_set_functioncode(::FunctionCode value);
  public:

  // int32 intervalTime = 6;
  void clear_intervaltime();
  int32_t intervaltime() const;
  void set_intervaltime(int32_t value);
  private:
  int32_t _internal_intervaltime() const;
  void _internal_set_intervaltime(int32_t value);
  public:

  // int32 startingAddress = 7;
  void clear_startingaddress();
  int32_t startingaddress() const;
  void set_startingaddress(int32_t value);
  private:
  int32_t _internal_startingaddress() const;
  void _internal_set_startingaddress(int32_t value);
  public:

  // int32 numberOfRegisters = 8;
  void clear_numberofregisters();
  int32_t numberofregisters() const;
  void set_numberofregisters(int32_t value);
  private:
  int32_t _internal_numberofregisters() const;
  void _internal_set_numberofregisters(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice.ModbusTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverid_;
  int datatype_;
  int functioncode_;
  int32_t intervaltime_;
  int32_t startingaddress_;
  int32_t numberofregisters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig_ModbusDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig.ModbusDevice) */ {
 public:
  inline ModbusConfig_ModbusDevice() : ModbusConfig_ModbusDevice(nullptr) {}
  ~ModbusConfig_ModbusDevice() override;
  explicit constexpr ModbusConfig_ModbusDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModbusConfig_ModbusDevice(const ModbusConfig_ModbusDevice& from);
  ModbusConfig_ModbusDevice(ModbusConfig_ModbusDevice&& from) noexcept
    : ModbusConfig_ModbusDevice() {
    *this = ::std::move(from);
  }

  inline ModbusConfig_ModbusDevice& operator=(const ModbusConfig_ModbusDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig_ModbusDevice& operator=(ModbusConfig_ModbusDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusConfig_ModbusDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusConfig_ModbusDevice* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig_ModbusDevice*>(
               &_ModbusConfig_ModbusDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModbusConfig_ModbusDevice& a, ModbusConfig_ModbusDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig_ModbusDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusConfig_ModbusDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusConfig_ModbusDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusConfig_ModbusDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModbusConfig_ModbusDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModbusConfig_ModbusDevice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig_ModbusDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig.ModbusDevice";
  }
  protected:
  explicit ModbusConfig_ModbusDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModbusConfig_ModbusDevice_ModbusRTUSlaves ModbusRTUSlaves;
  typedef ModbusConfig_ModbusDevice_ModbusTCPSlaves ModbusTCPSlaves;
  typedef ModbusConfig_ModbusDevice_ModbusTag ModbusTag;

  // accessors -------------------------------------------------------

  enum : int {
    kModbusTagFieldNumber = 4,
    kModbusRTUSlavesFieldNumber = 2,
    kModbusTCPSlavesFieldNumber = 3,
    kRtuOrTcpFieldNumber = 1,
  };
  // repeated .ModbusConfig.ModbusDevice.ModbusTag modbusTag = 4;
  int modbustag_size() const;
  private:
  int _internal_modbustag_size() const;
  public:
  void clear_modbustag();
  ::ModbusConfig_ModbusDevice_ModbusTag* mutable_modbustag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >*
      mutable_modbustag();
  private:
  const ::ModbusConfig_ModbusDevice_ModbusTag& _internal_modbustag(int index) const;
  ::ModbusConfig_ModbusDevice_ModbusTag* _internal_add_modbustag();
  public:
  const ::ModbusConfig_ModbusDevice_ModbusTag& modbustag(int index) const;
  ::ModbusConfig_ModbusDevice_ModbusTag* add_modbustag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >&
      modbustag() const;

  // .ModbusConfig.ModbusDevice.ModbusRTUSlaves modbusRTUSlaves = 2;
  bool has_modbusrtuslaves() const;
  private:
  bool _internal_has_modbusrtuslaves() const;
  public:
  void clear_modbusrtuslaves();
  const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& modbusrtuslaves() const;
  PROTOBUF_NODISCARD ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* release_modbusrtuslaves();
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* mutable_modbusrtuslaves();
  void set_allocated_modbusrtuslaves(::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves);
  private:
  const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& _internal_modbusrtuslaves() const;
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* _internal_mutable_modbusrtuslaves();
  public:
  void unsafe_arena_set_allocated_modbusrtuslaves(
      ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves);
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* unsafe_arena_release_modbusrtuslaves();

  // .ModbusConfig.ModbusDevice.ModbusTCPSlaves modbusTCPSlaves = 3;
  bool has_modbustcpslaves() const;
  private:
  bool _internal_has_modbustcpslaves() const;
  public:
  void clear_modbustcpslaves();
  const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& modbustcpslaves() const;
  PROTOBUF_NODISCARD ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* release_modbustcpslaves();
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* mutable_modbustcpslaves();
  void set_allocated_modbustcpslaves(::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves);
  private:
  const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& _internal_modbustcpslaves() const;
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* _internal_mutable_modbustcpslaves();
  public:
  void unsafe_arena_set_allocated_modbustcpslaves(
      ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves);
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* unsafe_arena_release_modbustcpslaves();

  // bool rtuOrTcp = 1;
  void clear_rtuortcp();
  bool rtuortcp() const;
  void set_rtuortcp(bool value);
  private:
  bool _internal_rtuortcp() const;
  void _internal_set_rtuortcp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ModbusConfig.ModbusDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag > modbustag_;
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves_;
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves_;
  bool rtuortcp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// -------------------------------------------------------------------

class ModbusConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModbusConfig) */ {
 public:
  inline ModbusConfig() : ModbusConfig(nullptr) {}
  ~ModbusConfig() override;
  explicit constexpr ModbusConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModbusConfig(const ModbusConfig& from);
  ModbusConfig(ModbusConfig&& from) noexcept
    : ModbusConfig() {
    *this = ::std::move(from);
  }

  inline ModbusConfig& operator=(const ModbusConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModbusConfig& operator=(ModbusConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModbusConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModbusConfig* internal_default_instance() {
    return reinterpret_cast<const ModbusConfig*>(
               &_ModbusConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModbusConfig& a, ModbusConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ModbusConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModbusConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModbusConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModbusConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModbusConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModbusConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModbusConfig";
  }
  protected:
  explicit ModbusConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModbusConfig_ModbusDevice ModbusDevice;

  // accessors -------------------------------------------------------

  enum : int {
    kModbusDeviceFieldNumber = 1,
  };
  // repeated .ModbusConfig.ModbusDevice modbusDevice = 1;
  int modbusdevice_size() const;
  private:
  int _internal_modbusdevice_size() const;
  public:
  void clear_modbusdevice();
  ::ModbusConfig_ModbusDevice* mutable_modbusdevice(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >*
      mutable_modbusdevice();
  private:
  const ::ModbusConfig_ModbusDevice& _internal_modbusdevice(int index) const;
  ::ModbusConfig_ModbusDevice* _internal_add_modbusdevice();
  public:
  const ::ModbusConfig_ModbusDevice& modbusdevice(int index) const;
  ::ModbusConfig_ModbusDevice* add_modbusdevice();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >&
      modbusdevice() const;

  // @@protoc_insertion_point(class_scope:ModbusConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice > modbusdevice_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modbus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModbusConfigResponse

// bool Success = 1;
inline void ModbusConfigResponse::clear_success() {
  success_ = false;
}
inline bool ModbusConfigResponse::_internal_success() const {
  return success_;
}
inline bool ModbusConfigResponse::success() const {
  // @@protoc_insertion_point(field_get:ModbusConfigResponse.Success)
  return _internal_success();
}
inline void ModbusConfigResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ModbusConfigResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ModbusConfigResponse.Success)
}

// int32 errorCode = 2;
inline void ModbusConfigResponse::clear_errorcode() {
  errorcode_ = 0;
}
inline int32_t ModbusConfigResponse::_internal_errorcode() const {
  return errorcode_;
}
inline int32_t ModbusConfigResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:ModbusConfigResponse.errorCode)
  return _internal_errorcode();
}
inline void ModbusConfigResponse::_internal_set_errorcode(int32_t value) {
  
  errorcode_ = value;
}
inline void ModbusConfigResponse::set_errorcode(int32_t value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:ModbusConfigResponse.errorCode)
}

// string errorDesc = 3;
inline void ModbusConfigResponse::clear_errordesc() {
  errordesc_.ClearToEmpty();
}
inline const std::string& ModbusConfigResponse::errordesc() const {
  // @@protoc_insertion_point(field_get:ModbusConfigResponse.errorDesc)
  return _internal_errordesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfigResponse::set_errordesc(ArgT0&& arg0, ArgT... args) {
 
 errordesc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfigResponse.errorDesc)
}
inline std::string* ModbusConfigResponse::mutable_errordesc() {
  std::string* _s = _internal_mutable_errordesc();
  // @@protoc_insertion_point(field_mutable:ModbusConfigResponse.errorDesc)
  return _s;
}
inline const std::string& ModbusConfigResponse::_internal_errordesc() const {
  return errordesc_.Get();
}
inline void ModbusConfigResponse::_internal_set_errordesc(const std::string& value) {
  
  errordesc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfigResponse::_internal_mutable_errordesc() {
  
  return errordesc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfigResponse::release_errordesc() {
  // @@protoc_insertion_point(field_release:ModbusConfigResponse.errorDesc)
  return errordesc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfigResponse::set_allocated_errordesc(std::string* errordesc) {
  if (errordesc != nullptr) {
    
  } else {
    
  }
  errordesc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errordesc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errordesc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    errordesc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfigResponse.errorDesc)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice_ModbusRTUSlaves

// string clientName = 1;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_clientname() {
  clientname_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::clientname() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 clientname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_clientname() const {
  return clientname_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_clientname(const std::string& value) {
  
  clientname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_mutable_clientname() {
  
  return clientname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::release_clientname() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
  return clientname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  clientname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientName)
}

// string clientID = 2;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_clientid() {
  clientid_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::clientid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_clientid() const {
  return clientid_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_clientid(const std::string& value) {
  
  clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_mutable_clientid() {
  
  return clientid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusRTUSlaves::release_clientid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
  return clientid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusRTUSlaves.clientID)
}

// .BaudRate baudRate = 3;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_baudrate() {
  baudrate_ = 0;
}
inline ::BaudRate ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_baudrate() const {
  return static_cast< ::BaudRate >(baudrate_);
}
inline ::BaudRate ModbusConfig_ModbusDevice_ModbusRTUSlaves::baudrate() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.baudRate)
  return _internal_baudrate();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_baudrate(::BaudRate value) {
  
  baudrate_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_baudrate(::BaudRate value) {
  _internal_set_baudrate(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.baudRate)
}

// .Parity parity = 4;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_parity() {
  parity_ = 0;
}
inline ::Parity ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_parity() const {
  return static_cast< ::Parity >(parity_);
}
inline ::Parity ModbusConfig_ModbusDevice_ModbusRTUSlaves::parity() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.parity)
  return _internal_parity();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_parity(::Parity value) {
  
  parity_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_parity(::Parity value) {
  _internal_set_parity(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.parity)
}

// int32 startBit = 5;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_startbit() {
  startbit_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_startbit() const {
  return startbit_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusRTUSlaves::startbit() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.startBit)
  return _internal_startbit();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_startbit(int32_t value) {
  
  startbit_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_startbit(int32_t value) {
  _internal_set_startbit(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.startBit)
}

// int32 stopBit = 6;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_stopbit() {
  stopbit_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_stopbit() const {
  return stopbit_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusRTUSlaves::stopbit() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.stopBit)
  return _internal_stopbit();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_stopbit(int32_t value) {
  
  stopbit_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_stopbit(int32_t value) {
  _internal_set_stopbit(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.stopBit)
}

// int32 dataBit = 7;
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::clear_databit() {
  databit_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_databit() const {
  return databit_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusRTUSlaves::databit() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusRTUSlaves.dataBit)
  return _internal_databit();
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::_internal_set_databit(int32_t value) {
  
  databit_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusRTUSlaves::set_databit(int32_t value) {
  _internal_set_databit(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusRTUSlaves.dataBit)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice_ModbusTCPSlaves

// string clientName = 1;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_clientname() {
  clientname_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::clientname() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 clientname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_clientname() const {
  return clientname_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_clientname(const std::string& value) {
  
  clientname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_mutable_clientname() {
  
  return clientname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::release_clientname() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
  return clientname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  clientname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientName)
}

// string clientID = 2;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_clientid() {
  clientid_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::clientid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
  return _internal_clientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_clientid(ArgT0&& arg0, ArgT... args) {
 
 clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_clientid() const {
  return clientid_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_clientid(const std::string& value) {
  
  clientid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_mutable_clientid() {
  
  return clientid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::release_clientid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
  return clientid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_allocated_clientid(std::string* clientid) {
  if (clientid != nullptr) {
    
  } else {
    
  }
  clientid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clientid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clientid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTCPSlaves.clientID)
}

// string IP = 3;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::ip() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_ip() const {
  return ip_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTCPSlaves::release_ip() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTCPSlaves.IP)
}

// int32 port = 4;
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::clear_port() {
  port_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_port() const {
  return port_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTCPSlaves::port() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTCPSlaves.port)
  return _internal_port();
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTCPSlaves::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTCPSlaves.port)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice_ModbusTag

// string tagName = 1;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::tagname() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.tagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusTag::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTag.tagName)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::_internal_tagname() const {
  return tagname_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::release_tagname() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTag.tagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tagname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tagname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTag.tagName)
}

// string tagId = 2;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_tagid() {
  tagid_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::tagid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.tagId)
  return _internal_tagid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusTag::set_tagid(ArgT0&& arg0, ArgT... args) {
 
 tagid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::mutable_tagid() {
  std::string* _s = _internal_mutable_tagid();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTag.tagId)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::_internal_tagid() const {
  return tagid_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_tagid(const std::string& value) {
  
  tagid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::_internal_mutable_tagid() {
  
  return tagid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::release_tagid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTag.tagId)
  return tagid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_allocated_tagid(std::string* tagid) {
  if (tagid != nullptr) {
    
  } else {
    
  }
  tagid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tagid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tagid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTag.tagId)
}

// string serverId = 3;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_serverid() {
  serverid_.ClearToEmpty();
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::serverid() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.serverId)
  return _internal_serverid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModbusConfig_ModbusDevice_ModbusTag::set_serverid(ArgT0&& arg0, ArgT... args) {
 
 serverid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::mutable_serverid() {
  std::string* _s = _internal_mutable_serverid();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.ModbusTag.serverId)
  return _s;
}
inline const std::string& ModbusConfig_ModbusDevice_ModbusTag::_internal_serverid() const {
  return serverid_.Get();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_serverid(const std::string& value) {
  
  serverid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::_internal_mutable_serverid() {
  
  return serverid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModbusConfig_ModbusDevice_ModbusTag::release_serverid() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.ModbusTag.serverId)
  return serverid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_allocated_serverid(std::string* serverid) {
  if (serverid != nullptr) {
    
  } else {
    
  }
  serverid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serverid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serverid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serverid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.ModbusTag.serverId)
}

// .ModbusDataType dataType = 4;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_datatype() {
  datatype_ = 0;
}
inline ::ModbusDataType ModbusConfig_ModbusDevice_ModbusTag::_internal_datatype() const {
  return static_cast< ::ModbusDataType >(datatype_);
}
inline ::ModbusDataType ModbusConfig_ModbusDevice_ModbusTag::datatype() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.dataType)
  return _internal_datatype();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_datatype(::ModbusDataType value) {
  
  datatype_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_datatype(::ModbusDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.dataType)
}

// .FunctionCode functionCode = 5;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_functioncode() {
  functioncode_ = 0;
}
inline ::FunctionCode ModbusConfig_ModbusDevice_ModbusTag::_internal_functioncode() const {
  return static_cast< ::FunctionCode >(functioncode_);
}
inline ::FunctionCode ModbusConfig_ModbusDevice_ModbusTag::functioncode() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.functionCode)
  return _internal_functioncode();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_functioncode(::FunctionCode value) {
  
  functioncode_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_functioncode(::FunctionCode value) {
  _internal_set_functioncode(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.functionCode)
}

// int32 intervalTime = 6;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_intervaltime() {
  intervaltime_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTag::_internal_intervaltime() const {
  return intervaltime_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTag::intervaltime() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.intervalTime)
  return _internal_intervaltime();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_intervaltime(int32_t value) {
  
  intervaltime_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_intervaltime(int32_t value) {
  _internal_set_intervaltime(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.intervalTime)
}

// int32 startingAddress = 7;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_startingaddress() {
  startingaddress_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTag::_internal_startingaddress() const {
  return startingaddress_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTag::startingaddress() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.startingAddress)
  return _internal_startingaddress();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_startingaddress(int32_t value) {
  
  startingaddress_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_startingaddress(int32_t value) {
  _internal_set_startingaddress(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.startingAddress)
}

// int32 numberOfRegisters = 8;
inline void ModbusConfig_ModbusDevice_ModbusTag::clear_numberofregisters() {
  numberofregisters_ = 0;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTag::_internal_numberofregisters() const {
  return numberofregisters_;
}
inline int32_t ModbusConfig_ModbusDevice_ModbusTag::numberofregisters() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.ModbusTag.numberOfRegisters)
  return _internal_numberofregisters();
}
inline void ModbusConfig_ModbusDevice_ModbusTag::_internal_set_numberofregisters(int32_t value) {
  
  numberofregisters_ = value;
}
inline void ModbusConfig_ModbusDevice_ModbusTag::set_numberofregisters(int32_t value) {
  _internal_set_numberofregisters(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.ModbusTag.numberOfRegisters)
}

// -------------------------------------------------------------------

// ModbusConfig_ModbusDevice

// bool rtuOrTcp = 1;
inline void ModbusConfig_ModbusDevice::clear_rtuortcp() {
  rtuortcp_ = false;
}
inline bool ModbusConfig_ModbusDevice::_internal_rtuortcp() const {
  return rtuortcp_;
}
inline bool ModbusConfig_ModbusDevice::rtuortcp() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.rtuOrTcp)
  return _internal_rtuortcp();
}
inline void ModbusConfig_ModbusDevice::_internal_set_rtuortcp(bool value) {
  
  rtuortcp_ = value;
}
inline void ModbusConfig_ModbusDevice::set_rtuortcp(bool value) {
  _internal_set_rtuortcp(value);
  // @@protoc_insertion_point(field_set:ModbusConfig.ModbusDevice.rtuOrTcp)
}

// .ModbusConfig.ModbusDevice.ModbusRTUSlaves modbusRTUSlaves = 2;
inline bool ModbusConfig_ModbusDevice::_internal_has_modbusrtuslaves() const {
  return this != internal_default_instance() && modbusrtuslaves_ != nullptr;
}
inline bool ModbusConfig_ModbusDevice::has_modbusrtuslaves() const {
  return _internal_has_modbusrtuslaves();
}
inline void ModbusConfig_ModbusDevice::clear_modbusrtuslaves() {
  if (GetArenaForAllocation() == nullptr && modbusrtuslaves_ != nullptr) {
    delete modbusrtuslaves_;
  }
  modbusrtuslaves_ = nullptr;
}
inline const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& ModbusConfig_ModbusDevice::_internal_modbusrtuslaves() const {
  const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* p = modbusrtuslaves_;
  return p != nullptr ? *p : reinterpret_cast<const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves&>(
      ::_ModbusConfig_ModbusDevice_ModbusRTUSlaves_default_instance_);
}
inline const ::ModbusConfig_ModbusDevice_ModbusRTUSlaves& ModbusConfig_ModbusDevice::modbusrtuslaves() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.modbusRTUSlaves)
  return _internal_modbusrtuslaves();
}
inline void ModbusConfig_ModbusDevice::unsafe_arena_set_allocated_modbusrtuslaves(
    ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modbusrtuslaves_);
  }
  modbusrtuslaves_ = modbusrtuslaves;
  if (modbusrtuslaves) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModbusConfig.ModbusDevice.modbusRTUSlaves)
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::release_modbusrtuslaves() {
  
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* temp = modbusrtuslaves_;
  modbusrtuslaves_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::unsafe_arena_release_modbusrtuslaves() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.modbusRTUSlaves)
  
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* temp = modbusrtuslaves_;
  modbusrtuslaves_ = nullptr;
  return temp;
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::_internal_mutable_modbusrtuslaves() {
  
  if (modbusrtuslaves_ == nullptr) {
    auto* p = CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusRTUSlaves>(GetArenaForAllocation());
    modbusrtuslaves_ = p;
  }
  return modbusrtuslaves_;
}
inline ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* ModbusConfig_ModbusDevice::mutable_modbusrtuslaves() {
  ::ModbusConfig_ModbusDevice_ModbusRTUSlaves* _msg = _internal_mutable_modbusrtuslaves();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.modbusRTUSlaves)
  return _msg;
}
inline void ModbusConfig_ModbusDevice::set_allocated_modbusrtuslaves(::ModbusConfig_ModbusDevice_ModbusRTUSlaves* modbusrtuslaves) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete modbusrtuslaves_;
  }
  if (modbusrtuslaves) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ModbusConfig_ModbusDevice_ModbusRTUSlaves>::GetOwningArena(modbusrtuslaves);
    if (message_arena != submessage_arena) {
      modbusrtuslaves = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modbusrtuslaves, submessage_arena);
    }
    
  } else {
    
  }
  modbusrtuslaves_ = modbusrtuslaves;
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.modbusRTUSlaves)
}

// .ModbusConfig.ModbusDevice.ModbusTCPSlaves modbusTCPSlaves = 3;
inline bool ModbusConfig_ModbusDevice::_internal_has_modbustcpslaves() const {
  return this != internal_default_instance() && modbustcpslaves_ != nullptr;
}
inline bool ModbusConfig_ModbusDevice::has_modbustcpslaves() const {
  return _internal_has_modbustcpslaves();
}
inline void ModbusConfig_ModbusDevice::clear_modbustcpslaves() {
  if (GetArenaForAllocation() == nullptr && modbustcpslaves_ != nullptr) {
    delete modbustcpslaves_;
  }
  modbustcpslaves_ = nullptr;
}
inline const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& ModbusConfig_ModbusDevice::_internal_modbustcpslaves() const {
  const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* p = modbustcpslaves_;
  return p != nullptr ? *p : reinterpret_cast<const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves&>(
      ::_ModbusConfig_ModbusDevice_ModbusTCPSlaves_default_instance_);
}
inline const ::ModbusConfig_ModbusDevice_ModbusTCPSlaves& ModbusConfig_ModbusDevice::modbustcpslaves() const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.modbusTCPSlaves)
  return _internal_modbustcpslaves();
}
inline void ModbusConfig_ModbusDevice::unsafe_arena_set_allocated_modbustcpslaves(
    ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(modbustcpslaves_);
  }
  modbustcpslaves_ = modbustcpslaves;
  if (modbustcpslaves) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModbusConfig.ModbusDevice.modbusTCPSlaves)
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::release_modbustcpslaves() {
  
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* temp = modbustcpslaves_;
  modbustcpslaves_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::unsafe_arena_release_modbustcpslaves() {
  // @@protoc_insertion_point(field_release:ModbusConfig.ModbusDevice.modbusTCPSlaves)
  
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* temp = modbustcpslaves_;
  modbustcpslaves_ = nullptr;
  return temp;
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::_internal_mutable_modbustcpslaves() {
  
  if (modbustcpslaves_ == nullptr) {
    auto* p = CreateMaybeMessage<::ModbusConfig_ModbusDevice_ModbusTCPSlaves>(GetArenaForAllocation());
    modbustcpslaves_ = p;
  }
  return modbustcpslaves_;
}
inline ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* ModbusConfig_ModbusDevice::mutable_modbustcpslaves() {
  ::ModbusConfig_ModbusDevice_ModbusTCPSlaves* _msg = _internal_mutable_modbustcpslaves();
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.modbusTCPSlaves)
  return _msg;
}
inline void ModbusConfig_ModbusDevice::set_allocated_modbustcpslaves(::ModbusConfig_ModbusDevice_ModbusTCPSlaves* modbustcpslaves) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete modbustcpslaves_;
  }
  if (modbustcpslaves) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ModbusConfig_ModbusDevice_ModbusTCPSlaves>::GetOwningArena(modbustcpslaves);
    if (message_arena != submessage_arena) {
      modbustcpslaves = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modbustcpslaves, submessage_arena);
    }
    
  } else {
    
  }
  modbustcpslaves_ = modbustcpslaves;
  // @@protoc_insertion_point(field_set_allocated:ModbusConfig.ModbusDevice.modbusTCPSlaves)
}

// repeated .ModbusConfig.ModbusDevice.ModbusTag modbusTag = 4;
inline int ModbusConfig_ModbusDevice::_internal_modbustag_size() const {
  return modbustag_.size();
}
inline int ModbusConfig_ModbusDevice::modbustag_size() const {
  return _internal_modbustag_size();
}
inline void ModbusConfig_ModbusDevice::clear_modbustag() {
  modbustag_.Clear();
}
inline ::ModbusConfig_ModbusDevice_ModbusTag* ModbusConfig_ModbusDevice::mutable_modbustag(int index) {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.ModbusDevice.modbusTag)
  return modbustag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >*
ModbusConfig_ModbusDevice::mutable_modbustag() {
  // @@protoc_insertion_point(field_mutable_list:ModbusConfig.ModbusDevice.modbusTag)
  return &modbustag_;
}
inline const ::ModbusConfig_ModbusDevice_ModbusTag& ModbusConfig_ModbusDevice::_internal_modbustag(int index) const {
  return modbustag_.Get(index);
}
inline const ::ModbusConfig_ModbusDevice_ModbusTag& ModbusConfig_ModbusDevice::modbustag(int index) const {
  // @@protoc_insertion_point(field_get:ModbusConfig.ModbusDevice.modbusTag)
  return _internal_modbustag(index);
}
inline ::ModbusConfig_ModbusDevice_ModbusTag* ModbusConfig_ModbusDevice::_internal_add_modbustag() {
  return modbustag_.Add();
}
inline ::ModbusConfig_ModbusDevice_ModbusTag* ModbusConfig_ModbusDevice::add_modbustag() {
  ::ModbusConfig_ModbusDevice_ModbusTag* _add = _internal_add_modbustag();
  // @@protoc_insertion_point(field_add:ModbusConfig.ModbusDevice.modbusTag)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice_ModbusTag >&
ModbusConfig_ModbusDevice::modbustag() const {
  // @@protoc_insertion_point(field_list:ModbusConfig.ModbusDevice.modbusTag)
  return modbustag_;
}

// -------------------------------------------------------------------

// ModbusConfig

// repeated .ModbusConfig.ModbusDevice modbusDevice = 1;
inline int ModbusConfig::_internal_modbusdevice_size() const {
  return modbusdevice_.size();
}
inline int ModbusConfig::modbusdevice_size() const {
  return _internal_modbusdevice_size();
}
inline void ModbusConfig::clear_modbusdevice() {
  modbusdevice_.Clear();
}
inline ::ModbusConfig_ModbusDevice* ModbusConfig::mutable_modbusdevice(int index) {
  // @@protoc_insertion_point(field_mutable:ModbusConfig.modbusDevice)
  return modbusdevice_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >*
ModbusConfig::mutable_modbusdevice() {
  // @@protoc_insertion_point(field_mutable_list:ModbusConfig.modbusDevice)
  return &modbusdevice_;
}
inline const ::ModbusConfig_ModbusDevice& ModbusConfig::_internal_modbusdevice(int index) const {
  return modbusdevice_.Get(index);
}
inline const ::ModbusConfig_ModbusDevice& ModbusConfig::modbusdevice(int index) const {
  // @@protoc_insertion_point(field_get:ModbusConfig.modbusDevice)
  return _internal_modbusdevice(index);
}
inline ::ModbusConfig_ModbusDevice* ModbusConfig::_internal_add_modbusdevice() {
  return modbusdevice_.Add();
}
inline ::ModbusConfig_ModbusDevice* ModbusConfig::add_modbusdevice() {
  ::ModbusConfig_ModbusDevice* _add = _internal_add_modbusdevice();
  // @@protoc_insertion_point(field_add:ModbusConfig.modbusDevice)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ModbusConfig_ModbusDevice >&
ModbusConfig::modbusdevice() const {
  // @@protoc_insertion_point(field_list:ModbusConfig.modbusDevice)
  return modbusdevice_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Parity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Parity>() {
  return ::Parity_descriptor();
}
template <> struct is_proto_enum< ::BaudRate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BaudRate>() {
  return ::BaudRate_descriptor();
}
template <> struct is_proto_enum< ::FunctionCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FunctionCode>() {
  return ::FunctionCode_descriptor();
}
template <> struct is_proto_enum< ::ModbusDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ModbusDataType>() {
  return ::ModbusDataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modbus_2eproto
